{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/firebase/admin.ts"],"sourcesContent":["\nimport admin from 'firebase-admin';\nimport fs from 'fs';\nimport path from 'path';\n\n// --- Initialization State ---\nlet adminAuthInstance: admin.auth.Auth | null = null;\nlet initializationError: Error | null = null;\nlet isInitializedAttempted = false; // Flag to prevent re-attempting initialization logic unnecessarily\nlet initializedVia: string | null = null; // Track how initialization was successful\nlet criticalLogMessages: string[] = []; // Store critical messages for the final error\n\n\n// --- Core Initialization Logic (Run Once) ---\nfunction initializeFirebaseAdmin(): void {\n    // Only attempt initialization once per process lifecycle\n    if (isInitializedAttempted) {\n        // Optional: reduce console noise on subsequent calls\n        // if (adminAuthInstance) { console.log(`Firebase Admin SDK: Already initialized successfully via ${initializedVia}.`); }\n        // else if (initializationError) { console.error(`Firebase Admin SDK: Initialization previously failed: ${initializationError.message}`); }\n        return;\n    }\n    isInitializedAttempted = true; // Mark that we are attempting/have attempted initialization\n\n    console.log(\"Firebase Admin SDK: Starting initialization attempt...\");\n    criticalLogMessages = []; // Reset messages for this attempt\n\n    let serviceAccountJson: string | null = null;\n    let localFilePathChecked: string | null = null;\n    let envVarChecked = false;\n\n    // --- Method 1: Environment Variable ---\n    envVarChecked = true;\n    console.log(\"Firebase Admin SDK: Checking environment variable FIREBASE_SERVICE_ACCOUNT_KEY...\");\n    if (process.env.FIREBASE_SERVICE_ACCOUNT_KEY && process.env.FIREBASE_SERVICE_ACCOUNT_KEY.trim() !== '' && process.env.FIREBASE_SERVICE_ACCOUNT_KEY.trim() !== '{}') {\n        console.log(\"Firebase Admin SDK: FIREBASE_SERVICE_ACCOUNT_KEY environment variable found (non-empty).\");\n        try {\n            serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT_KEY;\n            // Validate JSON structure rigorously\n            const parsed = JSON.parse(serviceAccountJson);\n            if (!parsed || typeof parsed !== 'object' || !parsed.project_id || !parsed.private_key || !parsed.client_email) {\n                const partialJson = serviceAccountJson.substring(0, 100) + (serviceAccountJson.length > 100 ? \"...\" : \"\");\n                console.error(`Firebase Admin SDK: Environment variable JSON content seems invalid or incomplete: ${partialJson}`);\n                const errorMsg = \"CRITICAL - Environment variable JSON is missing required fields (project_id, private_key, client_email).\";\n                criticalLogMessages.push(errorMsg);\n                throw new Error(errorMsg);\n            }\n            initializedVia = 'environment variable';\n            console.log(`Firebase Admin SDK: Found valid JSON in FIREBASE_SERVICE_ACCOUNT_KEY for project ${parsed.project_id}.`);\n        } catch (e: any) {\n            const errorMsg = `CRITICAL - Failed to parse service account JSON from environment variable. Ensure it's valid JSON. Error: ${e.message}`;\n            criticalLogMessages.push(errorMsg);\n            console.error(`Firebase Admin SDK: ${errorMsg}`);\n            initializationError = new Error(errorMsg);\n            // Do NOT proceed if env var is set but invalid\n            return;\n        }\n    } else {\n        console.log(\"Firebase Admin SDK: FIREBASE_SERVICE_ACCOUNT_KEY environment variable not found, empty, or just '{}'.\");\n    }\n\n    // --- Method 2: Local File ---\n    if (!serviceAccountJson) {\n        const serviceAccountFilename = 'reportzen-mixd3-firebase-adminsdk-fbsvc-f006f10e8d.json';\n        const serviceAccountPath = path.resolve(`./${serviceAccountFilename}`); // Get absolute path\n        localFilePathChecked = serviceAccountPath; // Record the path we checked\n        console.log(`Firebase Admin SDK: Checking for local file at ${serviceAccountPath}...`);\n        try {\n            if (fs.existsSync(serviceAccountPath)) {\n                const fileContent = fs.readFileSync(serviceAccountPath, 'utf8');\n                if (fileContent.trim() === '') {\n                    const warnMsg = `WARN - Local file ${serviceAccountFilename} exists but is empty. It will be ignored.`;\n                    console.warn(`Firebase Admin SDK: ${warnMsg}`);\n                    criticalLogMessages.push(warnMsg);\n                } else {\n                    console.log(`Firebase Admin SDK: Found local file ${serviceAccountFilename}. Reading content...`);\n                    serviceAccountJson = fileContent;\n                    // Validate JSON structure rigorously\n                    const parsed = JSON.parse(serviceAccountJson);\n                     if (!parsed || typeof parsed !== 'object' || !parsed.project_id || !parsed.private_key || !parsed.client_email) {\n                         const partialJson = serviceAccountJson.substring(0, 100) + (serviceAccountJson.length > 100 ? \"...\" : \"\");\n                         console.error(`Firebase Admin SDK: Local file JSON content seems invalid or incomplete: ${partialJson}`);\n                         const errorMsg = `CRITICAL - Local file ${serviceAccountFilename} JSON is missing required fields (project_id, private_key, client_email).`;\n                         criticalLogMessages.push(errorMsg);\n                        throw new Error(errorMsg);\n                    }\n                    initializedVia = `local file (${serviceAccountFilename})`;\n                    console.log(`Firebase Admin SDK: Found and read valid JSON from ${serviceAccountFilename} for project ${parsed.project_id}.`);\n                }\n            } else {\n                console.log(`Firebase Admin SDK: Local file ${serviceAccountFilename} not found at ${serviceAccountPath}.`);\n            }\n        } catch (error: any) {\n            let errorMsg;\n            if (error instanceof SyntaxError) {\n                errorMsg = `CRITICAL - Failed to parse service account JSON from ${serviceAccountFilename}. Ensure it's valid JSON. Error: ${error.message}`;\n            } else {\n                errorMsg = `CRITICAL - Error reading local file ${serviceAccountFilename}: ${error.message}`;\n            }\n            criticalLogMessages.push(errorMsg);\n            console.error(`Firebase Admin SDK: ${errorMsg}`);\n            initializationError = new Error(errorMsg);\n             // Do NOT proceed if local file is found but invalid\n            return;\n        }\n    }\n\n    // --- Check if Credentials Were Found ---\n    if (!serviceAccountJson) {\n        let errorMessage = \"CRITICAL - No valid service account credentials found. Cannot initialize.\";\n        if (envVarChecked) errorMessage += \" Checked environment variable 'FIREBASE_SERVICE_ACCOUNT_KEY'\";\n        if (localFilePathChecked) {\n            errorMessage += `${envVarChecked ? ' and' : ' Checked'} local file at '${localFilePathChecked}'`;\n        }\n        errorMessage += \".\";\n        criticalLogMessages.push(errorMessage);\n        console.error(`Firebase Admin SDK: ${errorMessage}`);\n        initializationError = new Error(errorMessage);\n        return; // Stop initialization\n    }\n\n    // --- Initialize Firebase Admin SDK (Only if not already initialized) ---\n    // Check if the default app already exists to avoid re-initialization error\n    if (admin.apps.length === 0) {\n        let serviceAccount;\n        try {\n            // Re-parsing is safe as we validated structure above\n            serviceAccount = JSON.parse(serviceAccountJson);\n            console.log(`Firebase Admin SDK: Attempting initialization via ${initializedVia || 'unknown source'}...`);\n            admin.initializeApp({\n                credential: admin.credential.cert(serviceAccount),\n                // Optionally add databaseURL if using Realtime Database\n                // databaseURL: `https://${serviceAccount.project_id}.firebaseio.com`\n            });\n            console.log(`Firebase Admin SDK: Initialization successful for project ${serviceAccount.project_id} via ${initializedVia}.`);\n            adminAuthInstance = admin.auth(); // Assign instance on success\n            initializationError = null; // Clear any previous errors on success\n            criticalLogMessages = []; // Clear logs on success\n        } catch (error: any) {\n            const errorMsg = `CRITICAL - Error during admin.initializeApp() via ${initializedVia || 'unknown source'}. Error: ${error.message}`;\n            criticalLogMessages.push(errorMsg);\n            console.error(`Firebase Admin SDK: ${errorMsg}`);\n            // Log details useful for debugging initialization failure\n            console.error(\"Service Account Project ID used:\", serviceAccount?.project_id || 'N/A');\n            console.error(\"Service Account Client Email used:\", serviceAccount?.client_email || 'N/A');\n            initializationError = new Error(errorMsg);\n            adminAuthInstance = null; // Ensure instance is null on failure\n        }\n    } else {\n        // If apps array is not empty, assume it's already initialized (by this process or another import)\n        console.log(`Firebase Admin SDK: Default app already exists. Using existing auth instance (initialized via ${initializedVia || 'previous import'}).`);\n        adminAuthInstance = admin.auth(); // Get auth from the existing default app\n        initializationError = null; // Clear potential errors if we're using existing\n        criticalLogMessages = [];\n    }\n}\n\n// --- Run Initialization on Module Load ---\ninitializeFirebaseAdmin();\n\n// --- Export Getter Function (Throws on Access if Initialization Failed) ---\nexport const getAdminAuth = (): admin.auth.Auth => {\n    if (initializationError) {\n        // Provide a more detailed error message upon access if initialization failed\n         throw new Error(`Firebase Admin SDK access failed: ${initializationError.message}. Check server startup logs for details. Common causes are missing, empty, or invalid service account credentials (env var 'FIREBASE_SERVICE_ACCOUNT_KEY' or local file 'reportzen-mixd3-firebase-adminsdk-fbsvc-f006f10e8d.json'). Please verify your setup according to the README.md.`);\n    }\n    if (!adminAuthInstance) {\n        // This case should theoretically not be reached if initialization logic is sound, but added for safety\n        // It might happen if the module somehow gets re-evaluated without re-running the top-level init.\n        console.error(\"Firebase Admin SDK: adminAuthInstance is unexpectedly null despite no recorded initializationError. Re-attempting initialization...\");\n        initializeFirebaseAdmin(); // Attempt recovery\n        if (initializationError) { // Check again after re-attempt\n            throw new Error(`Firebase Admin SDK access failed after re-initialization attempt: ${initializationError.message}. See logs.`);\n        }\n        if(!adminAuthInstance){\n             throw new Error(\"Firebase Admin SDK could not be initialized even after re-attempt. Critical failure. Check server logs.\");\n        }\n        console.warn(\"Firebase Admin SDK: Recovered adminAuthInstance after re-initialization.\");\n    }\n    return adminAuthInstance;\n};\n\n// Export other admin services if needed, ensuring they depend on successful auth init\n// Example for Firestore:\n// let adminDbInstance: admin.firestore.Firestore | null = null;\n// export function getAdminDb(): admin.firestore.Firestore {\n//      getAdminAuth(); // Ensures auth is checked first - will throw if auth failed\n//      if (!adminDbInstance) {\n//          adminDbInstance = admin.firestore();\n//      }\n//      return adminDbInstance;\n// }\n\n    "],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/list-users.ts"],"sourcesContent":["\n'use server';\n\nimport { getAdminAuth } from '@/lib/firebase/admin'; // Import the getter function\nimport type { UserRecord } from 'firebase-admin/auth';\n\n// Define return type\ninterface ListUsersResult {\n  success: boolean;\n  message: string;\n  users?: {\n    uid: string;\n    email: string | undefined; // Email might be undefined\n    creationTime: string;\n    lastSignInTime: string;\n    disabled: boolean;\n    isAdmin: boolean; // Added isAdmin flag\n    allowedSections: string[]; // Added allowed sections\n  }[];\n}\n\nexport async function listUsersAction(): Promise<ListUsersResult> {\n  let adminAuth;\n  try {\n    adminAuth = getAdminAuth(); // Get the admin auth instance\n    // If getAdminAuth doesn't throw, SDK is initialized\n  } catch (error: any) {\n    console.error('Error getting Firebase Admin Auth instance in listUsersAction:', error.message);\n    // Return a specific error indicating initialization failure\n    return {\n      success: false,\n      message: `Erreur critique: Impossible d'initialiser Firebase Admin SDK. Vérifiez les logs du serveur. (${error.message})`,\n    };\n  }\n\n  // --- Authentication/Authorization Check ---\n  // Ensure the caller is an admin. This is crucial for security.\n  // For now, we assume page-level protection. In a real app, implement robust server-side auth checks here.\n  // Example (requires passing user token):\n  // const userToken = headers().get('Authorization')?.split('Bearer ')[1];\n  // if (!userToken) return { success: false, message: \"Non autorisé.\" };\n  // try {\n  //   const decodedToken = await adminAuth.verifyIdToken(userToken);\n  //   if (!decodedToken.admin) { return { success: false, message: \"Accès refusé.\" }; }\n  // } catch (error) {\n  //    console.error(\"Auth check failed:\", error);\n  //    return { success: false, message: \"Erreur d'authentification.\" };\n  // }\n  // --- End Auth Check ---\n\n  try {\n    const listUsersResult = await adminAuth.listUsers(1000); // List up to 1000 users\n\n    const users = listUsersResult.users.map((userRecord: UserRecord) => {\n        // Check for the admin custom claim\n        const isAdminByClaim = !!userRecord.customClaims?.admin;\n        // Check if UID matches the primary admin UID from env var\n        const isAdminByUID = !!process.env.NEXT_PUBLIC_ADMIN_UID && userRecord.uid === process.env.NEXT_PUBLIC_ADMIN_UID;\n        const isAdmin = isAdminByClaim || isAdminByUID; // User is admin if either is true\n\n        // Get allowed sections claim, default to empty array if missing or invalid\n        const allowedSections = Array.isArray(userRecord.customClaims?.allowedSections)\n                                  ? userRecord.customClaims?.allowedSections as string[]\n                                  : [];\n\n\n        return {\n            uid: userRecord.uid,\n            email: userRecord.email,\n            creationTime: userRecord.metadata.creationTime,\n            lastSignInTime: userRecord.metadata.lastSignInTime,\n            disabled: userRecord.disabled,\n            isAdmin: isAdmin,\n            allowedSections: allowedSections, // Include allowed sections\n        };\n    });\n\n    // Optionally sort users, e.g., by creation time or email\n    users.sort((a, b) => new Date(b.creationTime).getTime() - new Date(a.creationTime).getTime());\n\n\n    return {\n      success: true,\n      message: `Successfully fetched ${users.length} users.`,\n      users: users,\n    };\n  } catch (error: any) {\n    console.error('Error listing users:', error);\n    // Provide more context in the error message\n    return {\n      success: false,\n      message: `Erreur lors de la récupération des utilisateurs: ${error.message}. (Code: ${error.code || 'N/A'})`,\n    };\n  }\n}\n"],"names":[],"mappings":";;;;;AAGA,6NAAqD,6BAA6B;;;;;AAkB3E,eAAe,uCAAa,GAAb;IACpB,IAAI;IACJ,IAAI;QACF,YAAY,CAAA,GAAA,+HAAA,CAAA,eAAY,AAAD,KAAK,8BAA8B;IAC1D,oDAAoD;IACtD,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kEAAkE,MAAM,OAAO;QAC7F,4DAA4D;QAC5D,OAAO;YACL,SAAS;YACT,SAAS,CAAC,6FAA6F,EAAE,MAAM,OAAO,CAAC,CAAC,CAAC;QAC3H;IACF;IAEA,6CAA6C;IAC7C,+DAA+D;IAC/D,0GAA0G;IAC1G,yCAAyC;IACzC,yEAAyE;IACzE,uEAAuE;IACvE,QAAQ;IACR,mEAAmE;IACnE,sFAAsF;IACtF,oBAAoB;IACpB,iDAAiD;IACjD,uEAAuE;IACvE,IAAI;IACJ,yBAAyB;IAEzB,IAAI;QACF,MAAM,kBAAkB,MAAM,UAAU,SAAS,CAAC,OAAO,wBAAwB;QAEjF,MAAM,QAAQ,gBAAgB,KAAK,CAAC,GAAG,CAAC,CAAC;YACrC,mCAAmC;YACnC,MAAM,iBAAiB,CAAC,CAAC,WAAW,YAAY,EAAE;YAClD,0DAA0D;YAC1D,MAAM,eAAe,CAAC,qEAAsC,WAAW,GAAG;YAC1E,MAAM,UAAU,kBAAkB,cAAc,kCAAkC;YAElF,2EAA2E;YAC3E,MAAM,kBAAkB,MAAM,OAAO,CAAC,WAAW,YAAY,EAAE,mBACnC,WAAW,YAAY,EAAE,kBACzB,EAAE;YAG9B,OAAO;gBACH,KAAK,WAAW,GAAG;gBACnB,OAAO,WAAW,KAAK;gBACvB,cAAc,WAAW,QAAQ,CAAC,YAAY;gBAC9C,gBAAgB,WAAW,QAAQ,CAAC,cAAc;gBAClD,UAAU,WAAW,QAAQ;gBAC7B,SAAS;gBACT,iBAAiB;YACrB;QACJ;QAEA,yDAAyD;QACzD,MAAM,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,YAAY,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,YAAY,EAAE,OAAO;QAG1F,OAAO;YACL,SAAS;YACT,SAAS,CAAC,qBAAqB,EAAE,MAAM,MAAM,CAAC,OAAO,CAAC;YACtD,OAAO;QACT;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,wBAAwB;QACtC,4CAA4C;QAC5C,OAAO;YACL,SAAS;YACT,SAAS,CAAC,iDAAiD,EAAE,MAAM,OAAO,CAAC,SAAS,EAAE,MAAM,IAAI,IAAI,MAAM,CAAC,CAAC;QAC9G;IACF;AACF;;;IAzEsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/set-user-role.ts"],"sourcesContent":["\n'use server';\n\nimport { getAdminAuth } from '@/lib/firebase/admin'; // Import the getter function\nimport { z } from 'zod';\n\n// Define input schema for validation\nconst SetUserRoleInputSchema = z.object({\n  uid: z.string().min(1, { message: \"UID utilisateur requis.\" }),\n  isAdmin: z.boolean(),\n});\n\n// Define return type\ninterface SetUserRoleResult {\n  success: boolean;\n  message: string;\n}\n\nexport async function setUserRoleAction(uid: string, isAdmin: boolean): Promise<SetUserRoleResult> {\n    const adminAuth = getAdminAuth(); // Get the admin auth instance\n\n    // --- Authorization Check ---\n    // Ensure the caller is an authenticated admin. This is CRUCIAL.\n    // For simplicity, we assume this check happens in the calling context (e.g., AdminPage)\n    // A more robust solution involves verifying an admin token here.\n    // --- End Auth Check ---\n\n    // Validate input (even though it comes from internal function call, good practice)\n    const validationResult = SetUserRoleInputSchema.safeParse({ uid, isAdmin });\n    if (!validationResult.success) {\n        const errorMessages = validationResult.error.errors.map(e => e.message).join(', ');\n        return { success: false, message: `Validation échouée: ${errorMessages}` };\n    }\n\n    // Prevent modifying the primary admin defined by environment variable\n    if (process.env.NEXT_PUBLIC_ADMIN_UID && uid === process.env.NEXT_PUBLIC_ADMIN_UID) {\n        return { success: false, message: \"Modification du rôle de l'administrateur principal non autorisée.\" };\n    }\n\n    try {\n        // Set custom claims\n        await adminAuth.setCustomUserClaims(uid, { admin: isAdmin });\n        console.log(`Successfully set admin claim to ${isAdmin} for user: ${uid}`);\n\n        // Optionally, force token refresh for the affected user if they are currently logged in\n        // This requires more complex logic, potentially involving Firestore or Realtime Database\n        // await adminAuth.revokeRefreshTokens(uid);\n\n        return {\n            success: true,\n            message: `Rôle admin ${isAdmin ? 'défini' : 'retiré'} avec succès pour l'utilisateur ${uid}.`,\n        };\n    } catch (error: any) {\n        console.error(`Error setting custom claims for user ${uid}:`, error);\n        let errorMessage = \"Erreur lors de la modification du rôle de l'utilisateur.\";\n        // Add more specific error handling based on Firebase Admin SDK errors if needed\n        if (error.code === 'auth/user-not-found') {\n            errorMessage = `User avec UID ${uid} non trouvé.`;\n        }\n        return { success: false, message: errorMessage };\n    }\n}\n"],"names":[],"mappings":";;;;;AAGA,6NAAqD,6BAA6B;AAClF;;;;;;AAEA,qCAAqC;AACrC,MAAM,yBAAyB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACtC,KAAK,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0B;IAC5D,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;AACpB;AAQO,eAAe,uCAAe,GAAf,kBAAkB,GAAW,EAAE,OAAgB;IACjE,MAAM,YAAY,CAAA,GAAA,+HAAA,CAAA,eAAY,AAAD,KAAK,8BAA8B;IAEhE,8BAA8B;IAC9B,gEAAgE;IAChE,wFAAwF;IACxF,iEAAiE;IACjE,yBAAyB;IAEzB,mFAAmF;IACnF,MAAM,mBAAmB,uBAAuB,SAAS,CAAC;QAAE;QAAK;IAAQ;IACzE,IAAI,CAAC,iBAAiB,OAAO,EAAE;QAC3B,MAAM,gBAAgB,iBAAiB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,EAAE,IAAI,CAAC;QAC7E,OAAO;YAAE,SAAS;YAAO,SAAS,CAAC,oBAAoB,EAAE,eAAe;QAAC;IAC7E;IAEA,sEAAsE;IACtE,IAAI,oEAAqC,0EAA2C;QAChF,OAAO;YAAE,SAAS;YAAO,SAAS;QAAoE;IAC1G;IAEA,IAAI;QACA,oBAAoB;QACpB,MAAM,UAAU,mBAAmB,CAAC,KAAK;YAAE,OAAO;QAAQ;QAC1D,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,QAAQ,WAAW,EAAE,KAAK;QAEzE,wFAAwF;QACxF,yFAAyF;QACzF,4CAA4C;QAE5C,OAAO;YACH,SAAS;YACT,SAAS,CAAC,WAAW,EAAE,UAAU,WAAW,SAAS,gCAAgC,EAAE,IAAI,CAAC,CAAC;QACjG;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,qCAAqC,EAAE,IAAI,CAAC,CAAC,EAAE;QAC9D,IAAI,eAAe;QACnB,gFAAgF;QAChF,IAAI,MAAM,IAAI,KAAK,uBAAuB;YACtC,eAAe,CAAC,cAAc,EAAE,IAAI,YAAY,CAAC;QACrD;QACA,OAAO;YAAE,SAAS;YAAO,SAAS;QAAa;IACnD;AACJ;;;IA3CsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 376, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/toggle-user-status.ts"],"sourcesContent":["\n'use server';\n\nimport { getAdminAuth } from '@/lib/firebase/admin'; // Import the getter function\nimport { z } from 'zod';\n\n// Define input schema for validation\nconst ToggleUserStatusInputSchema = z.object({\n  uid: z.string().min(1, { message: \"UID utilisateur requis.\" }),\n  disable: z.boolean(), // true to disable, false to enable\n});\n\n// Define return type\ninterface ToggleUserStatusResult {\n  success: boolean;\n  message: string;\n}\n\nexport async function toggleUserStatusAction(uid: string, disable: boolean): Promise<ToggleUserStatusResult> {\n    const adminAuth = getAdminAuth(); // Get the admin auth instance\n\n    // --- Authorization Check ---\n    // Ensure the caller is an authenticated admin.\n    // --- End Auth Check ---\n\n    // Validate input\n    const validationResult = ToggleUserStatusInputSchema.safeParse({ uid, disable });\n    if (!validationResult.success) {\n        const errorMessages = validationResult.error.errors.map(e => e.message).join(', ');\n        return { success: false, message: `Validation échouée: ${errorMessages}` };\n    }\n\n     // Prevent disabling the primary admin defined by environment variable\n    if (disable && process.env.NEXT_PUBLIC_ADMIN_UID && uid === process.env.NEXT_PUBLIC_ADMIN_UID) {\n        return { success: false, message: \"Désactivation de l'administrateur principal non autorisée.\" };\n    }\n\n    try {\n        // Update user status\n        await adminAuth.updateUser(uid, { disabled: disable });\n        console.log(`Successfully ${disable ? 'disabled' : 'enabled'} user: ${uid}`);\n\n        return {\n            success: true,\n            message: `User ${disable ? 'désactivé' : 'activé'} avec succès.`,\n        };\n    } catch (error: any) {\n        console.error(`Error updating status for user ${uid}:`, error);\n        let errorMessage = \"Erreur lors de la modification du statut de l'utilisateur.\";\n        if (error.code === 'auth/user-not-found') {\n            errorMessage = `User avec UID ${uid} non trouvé.`;\n        }\n        return { success: false, message: errorMessage };\n    }\n}\n"],"names":[],"mappings":";;;;;AAGA,6NAAqD,6BAA6B;AAClF;;;;;;AAEA,qCAAqC;AACrC,MAAM,8BAA8B,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC3C,KAAK,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0B;IAC5D,SAAS,oIAAA,CAAA,IAAC,CAAC,OAAO;AACpB;AAQO,eAAe,uCAAoB,GAApB,uBAAuB,GAAW,EAAE,OAAgB;IACtE,MAAM,YAAY,CAAA,GAAA,+HAAA,CAAA,eAAY,AAAD,KAAK,8BAA8B;IAEhE,8BAA8B;IAC9B,+CAA+C;IAC/C,yBAAyB;IAEzB,iBAAiB;IACjB,MAAM,mBAAmB,4BAA4B,SAAS,CAAC;QAAE;QAAK;IAAQ;IAC9E,IAAI,CAAC,iBAAiB,OAAO,EAAE;QAC3B,MAAM,gBAAgB,iBAAiB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,EAAE,IAAI,CAAC;QAC7E,OAAO;YAAE,SAAS;YAAO,SAAS,CAAC,oBAAoB,EAAE,eAAe;QAAC;IAC7E;IAEC,sEAAsE;IACvE,IAAI,+EAAgD,0EAA2C;QAC3F,OAAO;YAAE,SAAS;YAAO,SAAS;QAA6D;IACnG;IAEA,IAAI;QACA,qBAAqB;QACrB,MAAM,UAAU,UAAU,CAAC,KAAK;YAAE,UAAU;QAAQ;QACpD,QAAQ,GAAG,CAAC,CAAC,aAAa,EAAE,UAAU,aAAa,UAAU,OAAO,EAAE,KAAK;QAE3E,OAAO;YACH,SAAS;YACT,SAAS,CAAC,KAAK,EAAE,UAAU,cAAc,SAAS,aAAa,CAAC;QACpE;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,+BAA+B,EAAE,IAAI,CAAC,CAAC,EAAE;QACxD,IAAI,eAAe;QACnB,IAAI,MAAM,IAAI,KAAK,uBAAuB;YACtC,eAAe,CAAC,cAAc,EAAE,IAAI,YAAY,CAAC;QACrD;QACA,OAAO;YAAE,SAAS;YAAO,SAAS;QAAa;IACnD;AACJ;;;IApCsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/delete-user.ts"],"sourcesContent":["\n'use server';\n\nimport { getAdminAuth } from '@/lib/firebase/admin'; // Import the getter function\nimport { z } from 'zod';\n\n// Define input schema for validation\nconst DeleteUserInputSchema = z.object({\n  uid: z.string().min(1, { message: \"UID utilisateur requis.\" }),\n});\n\n// Define return type\ninterface DeleteUserResult {\n  success: boolean;\n  message: string;\n}\n\nexport async function deleteUserAction(uid: string): Promise<DeleteUserResult> {\n    const adminAuth = getAdminAuth(); // Get the admin auth instance\n\n    // --- Authorization Check ---\n    // Ensure the caller is an authenticated admin.\n    // --- End Auth Check ---\n\n    // Validate input\n    const validationResult = DeleteUserInputSchema.safeParse({ uid });\n    if (!validationResult.success) {\n        const errorMessages = validationResult.error.errors.map(e => e.message).join(', ');\n        return { success: false, message: `Validation échouée: ${errorMessages}` };\n    }\n\n     // Prevent deleting the primary admin defined by environment variable\n    if (process.env.NEXT_PUBLIC_ADMIN_UID && uid === process.env.NEXT_PUBLIC_ADMIN_UID) {\n        return { success: false, message: \"Suppression de l'administrateur principal non autorisée.\" };\n    }\n\n\n    try {\n        // Delete user\n        await adminAuth.deleteUser(uid);\n        console.log(`Successfully deleted user: ${uid}`);\n\n        return {\n            success: true,\n            message: `User supprimé avec succès.`,\n        };\n    } catch (error: any) {\n        console.error(`Error deleting user ${uid}:`, error);\n        let errorMessage = \"Erreur lors de la suppression de l'utilisateur.\";\n        if (error.code === 'auth/user-not-found') {\n            errorMessage = `User avec UID ${uid} non trouvé.`;\n        }\n        // Add more specific error handling based on Firebase Admin SDK errors if needed\n        return { success: false, message: errorMessage };\n    }\n}\n"],"names":[],"mappings":";;;;;AAGA,6NAAqD,6BAA6B;AAClF;;;;;;AAEA,qCAAqC;AACrC,MAAM,wBAAwB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrC,KAAK,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0B;AAC9D;AAQO,eAAe,uCAAc,GAAd,iBAAiB,GAAW;IAC9C,MAAM,YAAY,CAAA,GAAA,+HAAA,CAAA,eAAY,AAAD,KAAK,8BAA8B;IAEhE,8BAA8B;IAC9B,+CAA+C;IAC/C,yBAAyB;IAEzB,iBAAiB;IACjB,MAAM,mBAAmB,sBAAsB,SAAS,CAAC;QAAE;IAAI;IAC/D,IAAI,CAAC,iBAAiB,OAAO,EAAE;QAC3B,MAAM,gBAAgB,iBAAiB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,EAAE,IAAI,CAAC;QAC7E,OAAO;YAAE,SAAS;YAAO,SAAS,CAAC,oBAAoB,EAAE,eAAe;QAAC;IAC7E;IAEC,qEAAqE;IACtE,IAAI,oEAAqC,0EAA2C;QAChF,OAAO;YAAE,SAAS;YAAO,SAAS;QAA2D;IACjG;IAGA,IAAI;QACA,cAAc;QACd,MAAM,UAAU,UAAU,CAAC;QAC3B,QAAQ,GAAG,CAAC,CAAC,2BAA2B,EAAE,KAAK;QAE/C,OAAO;YACH,SAAS;YACT,SAAS,CAAC,0BAA0B,CAAC;QACzC;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,oBAAoB,EAAE,IAAI,CAAC,CAAC,EAAE;QAC7C,IAAI,eAAe;QACnB,IAAI,MAAM,IAAI,KAAK,uBAAuB;YACtC,eAAe,CAAC,cAAc,EAAE,IAAI,YAAY,CAAC;QACrD;QACA,gFAAgF;QAChF,OAAO;YAAE,SAAS;YAAO,SAAS;QAAa;IACnD;AACJ;;;IAtCsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 525, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/actions/set-user-permissions.ts"],"sourcesContent":["\n'use server';\n\nimport { getAdminAuth } from '@/lib/firebase/admin'; // Import the getter function\nimport { z } from 'zod';\n\n// Define input schema for validation\nconst SetUserPermissionsInputSchema = z.object({\n  uid: z.string().min(1, { message: \"UID utilisateur requis.\" }),\n  allowedSections: z.array(z.string()), // Expect an array of section IDs/names\n});\n\n// Define return type\ninterface SetUserPermissionsResult {\n  success: boolean;\n  message: string;\n}\n\nexport async function setUserPermissionsAction(uid: string, allowedSections: string[]): Promise<SetUserPermissionsResult> {\n    const adminAuth = getAdminAuth(); // Get the admin auth instance\n\n    // --- Authorization Check ---\n    // Ensure the caller is an authenticated admin. This is CRUCIAL.\n    // For simplicity, assume page-level protection or verify token here.\n    // --- End Auth Check ---\n\n    // Validate input\n    const validationResult = SetUserPermissionsInputSchema.safeParse({ uid, allowedSections });\n    if (!validationResult.success) {\n        const errorMessages = validationResult.error.errors.map(e => e.message).join(', ');\n        return { success: false, message: `Validation échouée: ${errorMessages}` };\n    }\n\n    // Prevent modifying the primary admin defined by environment variable\n    if (process.env.NEXT_PUBLIC_ADMIN_UID && uid === process.env.NEXT_PUBLIC_ADMIN_UID) {\n        return { success: false, message: \"Modification des permissions de l'administrateur principal non autorisée.\" };\n    }\n\n    try {\n        // Get existing claims to merge, ensuring 'admin' claim is preserved\n        const userRecord = await adminAuth.getUser(uid);\n        const existingClaims = userRecord.customClaims || {};\n\n        // Set or update the allowedSections claim, merging with existing claims\n        await adminAuth.setCustomUserClaims(uid, {\n             ...existingClaims, // Preserve existing claims\n             allowedSections: allowedSections // Set/Overwrite allowedSections\n        });\n        console.log(`Successfully set allowedSections for user: ${uid}`, allowedSections);\n\n        // Optionally force token refresh if the user might be currently logged in\n        // await adminAuth.revokeRefreshTokens(uid);\n\n        return {\n            success: true,\n            message: `Permissions mises à jour avec succès pour l'utilisateur ${uid}.`,\n        };\n    } catch (error: any) {\n        console.error(`Error setting custom claims for user ${uid}:`, error);\n        let errorMessage = \"Erreur lors de la modification des permissions de l'utilisateur.\";\n        if (error.code === 'auth/user-not-found') {\n            errorMessage = `User avec UID ${uid} non trouvé.`;\n        }\n        return { success: false, message: errorMessage };\n    }\n}\n"],"names":[],"mappings":";;;;;AAGA,6NAAqD,6BAA6B;AAClF;;;;;;AAEA,qCAAqC;AACrC,MAAM,gCAAgC,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,KAAK,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;QAAE,SAAS;IAA0B;IAC5D,iBAAiB,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,oIAAA,CAAA,IAAC,CAAC,MAAM;AACnC;AAQO,eAAe,uCAAsB,GAAtB,yBAAyB,GAAW,EAAE,eAAyB;IACjF,MAAM,YAAY,CAAA,GAAA,+HAAA,CAAA,eAAY,AAAD,KAAK,8BAA8B;IAEhE,8BAA8B;IAC9B,gEAAgE;IAChE,qEAAqE;IACrE,yBAAyB;IAEzB,iBAAiB;IACjB,MAAM,mBAAmB,8BAA8B,SAAS,CAAC;QAAE;QAAK;IAAgB;IACxF,IAAI,CAAC,iBAAiB,OAAO,EAAE;QAC3B,MAAM,gBAAgB,iBAAiB,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,OAAO,EAAE,IAAI,CAAC;QAC7E,OAAO;YAAE,SAAS;YAAO,SAAS,CAAC,oBAAoB,EAAE,eAAe;QAAC;IAC7E;IAEA,sEAAsE;IACtE,IAAI,oEAAqC,0EAA2C;QAChF,OAAO;YAAE,SAAS;YAAO,SAAS;QAA4E;IAClH;IAEA,IAAI;QACA,oEAAoE;QACpE,MAAM,aAAa,MAAM,UAAU,OAAO,CAAC;QAC3C,MAAM,iBAAiB,WAAW,YAAY,IAAI,CAAC;QAEnD,wEAAwE;QACxE,MAAM,UAAU,mBAAmB,CAAC,KAAK;YACpC,GAAG,cAAc;YACjB,iBAAiB,gBAAgB,gCAAgC;QACtE;QACA,QAAQ,GAAG,CAAC,CAAC,2CAA2C,EAAE,KAAK,EAAE;QAEjE,0EAA0E;QAC1E,4CAA4C;QAE5C,OAAO;YACH,SAAS;YACT,SAAS,CAAC,wDAAwD,EAAE,IAAI,CAAC,CAAC;QAC9E;IACJ,EAAE,OAAO,OAAY;QACjB,QAAQ,KAAK,CAAC,CAAC,qCAAqC,EAAE,IAAI,CAAC,CAAC,EAAE;QAC9D,IAAI,eAAe;QACnB,IAAI,MAAM,IAAI,KAAK,uBAAuB;YACtC,eAAe,CAAC,cAAc,EAAE,IAAI,YAAY,CAAC;QACrD;QACA,OAAO;YAAE,SAAS;YAAO,SAAS;QAAa;IACnD;AACJ;;;IA/CsB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 685, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/admin/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/admin/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/admin/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAA0R,GACvT,wDACA","debugId":null}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/admin/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/admin/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/admin/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAsQ,GACnS,oCACA","debugId":null}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}